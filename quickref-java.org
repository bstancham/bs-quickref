==== JAVA QUICKSTART GUIDE ===========================================

FUNDAMENTALS:
- compiled
- static typed
- one class per source file (although inner-classes are allowed)
- hosted: JVM ---> Java Virtual Machine

* ========================== JAVA VERSIONS ===========================
Long term support (LTS):
- java 11 (released September 2018)
- java 17 (due for release in September 2021)

For Raspberry Pi:
- July 2021: use java 11

* =================== COMPILING AND RUNNING PROGRAMS ===================
** COMPILATION
$ javac MainClassName.java

$ javac src/path/to/MainClass.java -d build

$ jar cvf blahblah.jar build/path/to/*.class

Including a jar on the classpath:





** RUNNING
$ java MainClassName

** BUILDING JAVADOC

MAKE JAVADOC:

** JAR FILES

execute a jar (only works if jar manifest has a main class defined)
$ java -jar pingo.jar

execute a jar without main class in manifest...
... include the jar on the classpath
$ java -cp path/to/jarfile.jar path.of.MainClass

execute a jar with classpath...
... the -jar command causes -cp to be ignored, so instead, we put all the
files and jars we need on the classpath, then give the main class (which is
inside one of the jars on the classpath)...
$ java -cp .:lib/plopplop.jar:lib/pingo.jar path.to.MainClass



list content of jar file
$ jar tf FILENAME.jar

** JUNIT

http://www.vogella.com/tutorials/JUnit/article.html#usingjuni4

** ADDITIONAL TOOLS
*** checkstyle

*** findbugs

http://findbugs.sourceforge.net/index.html

* ======================== GRADLE (build tool) =========================
- gradle is the current thing (2017)
- mostly automatic, based on using a conventional project structure...
- will automatically download dependencies from repository!

** get latest gradle version
The version in the debian package repo is very old at time of writing (sept 2017)

I followed the instruction on the gradle website and used SDKMAN! to download latest:

$ sdk install gradle 7.1.1

used curl to install SDKMAN

$ curl -s "https://get.sdkman.io" | bash

installed curl with apt-get

$ sudo apt-get install curl

** setup a new project
Inside the project directory:

 $ gradle init

... you will be prompted to answer a few questions...

:questions:
Select type of project to generate:
  1: basic
  2: application
  3: library
  4: Gradle plugin
Enter selection (default: basic) [1..4] 3

Select implementation language:
  1: C++
  2: Groovy
  3: Java
  4: Kotlin
  5: Scala
  6: Swift
Enter selection (default: Java) [1..6] 3

Select build script DSL:
  1: Groovy
  2: Kotlin
Enter selection (default: Groovy) [1..2] 1

Select test framework:
  1: JUnit 4
  2: TestNG
  3: Spock
  4: JUnit Jupiter
Enter selection (default: JUnit Jupiter) [1..4] 1
:END:

Project name (default: bsswingmenu): 
Source package (default: bsswingmenu): info.bstancham.bsswingmenu

That's it!

** upgrade gradle wrapper
# create gradle-wrapper in current working dir
$ gradle wrapper --gradle-version 7.1.1
# setup a default project structure using a preset template
$ gradlew init --type java-application

Default project templates include:
... java-library
... java-application

** command line usage

NOTE: use the gradle wrapper for all tasks because it will likely be a
newer version than the gradle binary on the system...

$ ./gradlew -h        # show help

$ ./gradlew build     # compile program and run tests
$ ./gradlew run       # run program
$ ./gradlew build run # ... tasks can be strung together like so

$ ./gradlew javadoc   # build javadoc (not part of the normal java build task)

** gradle build scripts
*** groovy
FILENAME: build.gradle

// include local jar files
dependencies {
    // need bsutil for compilation
    implementation files('/home/benopod/lib/bsutil.jar')
}

// make program version code available as a manifest attribute (relies on shell script to get version string from git)
jar {
    manifest {
        attributes 'bstpg-version': "get-version-string.sh".execute().text
    }
}

// copies final jar file to ~/lib/
task copyJarToLib(type: Copy) {
    String homeDir = System.getProperty('user.home');
    description 'Copies final jar file into ~/lib/'
    from 'build/libs/bstpg-base.jar'
    into homeDir + '/lib'
}

// managing task dependencies
copyJarToLib.dependsOn build
copyJarToLib.mustRunAfter build
task all {}
all.dependsOn([build, copyJarToLib])

// add command line arguments for the main compile task
tasks.withType(JavaCompile) {
  options.compilerArgs << "-Xlint:unchecked"
  options.compilerArgs << "-Xlint:deprecation"
}

TASKS: https://docs.gradle.org/current/userguide/tutorial_using_tasks.html

*** groovy build script DSL
build scripts use .gradle filename extension

*** kotlin build script DSL
build scripts use .gradle.kts filename extension

** gradle settings file
settings.gradle

// name of jar file is set by this
rootProject.name = 'myjarname'

** gradle and emacs

USE GRADLE WRAPPER:
Make sure that gradle-use-gradlew is ON...
... `M-x customize` and search for gradle...

BASIC USAGE:
M-x gradle-mode  ; activate gradle
M-x gradle-build ; build jar and run tests
... I've bound <f6> to gradle-execute in java-mode-hook (see .emacs)

M-x gradle-execute [TASK]
M-x gradle-execute build     ; same as gradle-build (build & run tests)
M-x gradle-execute run       ; run program
M-x gradle-execute build run ; build, then run program
... bind this to something... note 'gradle-run' is the non-interactive internal version of gradle-execute used by gradle-mode...

COMPILATION BUFFER ISSUES:
Use -q (quiet flag) to suppress messages during compilation...
... otherwise the first error is not properly formatted for jumping to...
... so, my normal usage is:
<f6>         ; gradle-execute
-q all <RET> ; 'all' runs build, copyToLib, javadoc

** gradle issues/troubleshooting

>>>> The requested build setup type 'java-application' is not supported.
PROBLEM: I had an old version of gradle... (version 2.10) that type hadn't been added yet.
SOLUTION: Use the gradle wrapper for building...
... upgrade gradle wrapper to newer version with:
$ gradle wrapper --gradle-version 3.3
$ ./gradlew -v # spends a while downloading & installing new version, then tells me version is 3.3!
... NOTE: gradle is still old version... this is why we must use gradlew for build!
$ ./gradlew init --type java-application # this now works



>>>>> java: symbol lookup error: /usr/lib/jni/libnative-platform-curses.so: undefined symbol: tgetent
SITUATION: gradle init --type java-application
PROBLEM:
SOLUTION:

* ============================= PROFILING ==============================
** VisualVM (Oracle)
... default profiling tool bundled with oracle's JDK...
... not included in debian openjdk package, but available separately:
$ sudo apt-get install visualvm
$ which visualvm # /usr/bin/visualvm

USAGE:
$ visualvm

... any currently running java programs should show up automatically in the
Applications window on the left hand side...

** Yourkit

** Plumbr

** Java Mission Control

* ============================== DEBUGGER ==============================
** jdb --- command line debugger (comes with jdk)

$ jdb [options] [class] [arguments]


COMPILATION

Compile program with -g option to generate all debugging information - otherwise
you will not be able to inspect local variables etc...
$ javac -g MyClass.java


RUNNING

To run a debugging session, pretty much just substitute the jdb command for the java command...
$ jdb [options] MyClass [arguments]



JDB SESSION WALKTHROUGH

Compile with debug option:
$ javac -g MyClass.java

Start jdb with compiled class:
$ jdb MyClass

Set a breakpoint in a method:
> stop in MyClass.myMethod

Set a breakpoint at a certain line of the sourcecode:
> stop at MyClass:123

Run program:
> run

... should stop at breakpoint...

... some useful commands...
> help    --> show list of commands
> print a --> print value of a.toString()
> dump a  --> show ALL information about object 'a'
> locals  --> list local variables
> classes/class/methods/fields --> list information...
> list    --> show position of execution in program listing
> step    --> execute one more line then stop
> cont    --> continue till next breakpoint
> where   --> dump thread's stack
> clear   --> list breakpoints set
> exit    --> exit jdb
> catch <class id> --> break for specified exception

* ====================== DIAGNOSE MEMORY LEAKS =======================
** introduction
A memory leak occurs when object references that are no longer needed are
unnecessarily maintained.

There four categories of memory issues with similar and overlapping symptoms,
but varied causes and solutions:

- PERFORMANCE: usually associated with excessive object creation and deletion,
  long delays in garbage collection, excessive operating system page swapping,
  and more.

- RESOURCE CONSTRAINTS: occurs when there’s either to little memory available or
  your memory is too fragmented to allocate a large object—this can be native
  or, more commonly, Java heap-related.

- JAVA HEAP LEAKS: the classic memory leak, in which Java objects are
  continuously created without being released. This is usually caused by latent
  object references.

- NATIVE MEMORY LEAKS: associated with any continuously growing memory
  utilization that is outside the Java heap, such as allocations made by JNI
  code, drivers or even JVM allocations.
** resources
https://www.toptal.com/java/hunting-memory-leaks-in-java
https://docs.oracle.com/en/java/javase/12/troubleshoot/troubleshoot-memory-leaks.html#GUID-8090B138-6E0C-4926-9659-BE739062AB75
https://dzone.com/articles/how-to-diagnose-memory-leaks
https://stackify.com/memory-leaks-java/
https://developers.redhat.com/blog/2014/08/14/find-fix-memory-leaks-java-application/
https://blog.gceasy.io/2016/11/22/resolve-memory-leak/
** java.lang.OutOfMemoryError: unable to create new native thread
https://dzone.com/articles/troubleshoot-outofmemoryerror-unable-to-create-new

* ============= OTHER TOOLS FOR DIAGNOSIS AND DEBUGGING ==============
** jps - list java processes on computer
like ps but for java
some java processes may not be listed by ps
list java virtual machines instrumented on computer
* ============================ NEW FEATURES ============================

JAVA 9
- jshell REPL
- project jigsaw (modularization of the JDK)

JAVA 8
- lambda and functional interfaces etc
- javafx (direct launching of JavaFX application JARs)

JAVA 7
- Strings allowed in switch statement
- Improved type inference for generic instance creation, aka the diamond operator <>
- Simplified varargs method declaration
- underscores in number literals

* ================= JSHELL (JAVA REPL - since Java 9) ==================

TIPS:
- Use TAB-completion to see which methods are available...

Start jshell:
  $ jshell

Exit repl:
  jshell> /exit

Show commands:
  jshell> /help

List methods/variables/types/imports defined during current session:
  jshell> /methods
  jshell> /vars
  jshell> /types
  jshell> /imports

Get IDs for snippets...
  jshell> /list
... can re-run any snippet with /<id>
... re-run last snippet with /!

  jshell> /edit helloMethod --- edit helloMethod in external editor

IN DEPTH TUTORIAL:
http://cr.openjdk.java.net/~rfield/tutorial/JShellTutorial.html
** defining and editing snippets

The basic unit of code used by JShell is the SNIPPET, or source entry. Every
time you declare a local variable or define a local method or class, you create
a snippet whose name is the identifier of the variable/method/class.

Defining a class with a do-nothing method:
jshell> class Bingo {
   ...> void flip() {
   ...> }
   ...> }

Can edit a snippet you have created with the /edit command...
... this will open it in the default editor:
jshell> /edit Bingo
... save file and exit editor to return to jshell

Can choose which editor to use:
jshell /set editor emacs
jshell /set editor nano # maybe better for very simple edits (starts up very fast)

** adding to classpath

add a dir to classpath...
jshell> /env -class-path build/classes/java/

jshell> /env -class-path ~/ComputerWork/NOTES/Java/jshell:build/classes/java/main

show classpath (and any other environment variables...
jshell> /env

import a class from classpath...
jshell> import bsjshell.BSJS;

show all current imports...
jshell> /imports

** BSJS utility class

I have made a few useful static methods in bsjshell.BSJS

Add to classpath...
jshell> /env -class-path ~/ComputerWork/NOTES/Java/jshell

Import all static methods...
jshell> import static bsjshell.BSJS.*;

Use a method...
jshell> printByte((byte) 5);

* =========================== JAVA AND EMACS ===========================

My Setup:

java-mode

meghanada-mode
... completion
... ... etc...

auto-completion
... company

compilation
... gradle-mode

version control
... git/magit

jump to definition
... etags

documentation browsing
... firefox (bookmarked pages)

TODO:
speedbar --> M-x speedbar
jtags

** Meghanada mode
install from melpa

on install, meghanada server is automatically downloaded and installed...
... everything works very easily...

Meghanada is a minor mode which adds some IDE style features for java editing
... code completion using company
... syntax checking using flycheck
... improved jump-to-definition
... commands to launch external debugger (e.g. realgud)

C-c C-r i ; meghanada-import-all
C-c C-r o ; meghanada-optimize-import

** Java dev setup from Peter Goldsborough's blog:

http://www.goldsborough.me/emacs,/java/2016/02/24/22-54-16-setting_up_emacs_for_java_development/
- eclim :   emacs-eclim : eclipse server
- gradle :  for compilation
- company : for autocompletion

** ECLIM
- eclim
- eclimd --- the eclim daemon
...
... if problems running, try...
M-x customize-variable RET eclimd-executable
M-x customize-variable RET eclim-executable
...



M-x start-eclimd ; start the eclipse server
M-x eclim-mode

M-x eclim-project-create
M-x eclim-project-open



ECLIM ISSUES
... always look in *messages* and eclimd.log for hints... also /workspace/.metadata/.log...

Tue Apr 25 23:52:31 2017
---> ECLIM-PROJECT-CREATE FAILED:
(in *messages*) error in process filter: eclim--check-project: invalid project:
(in eclim.log)  Contains: /home/benopod/ComputerWork/NOTES/eclim-test overlaps the workspace location: /home/benopod/ComputerWork/NOTES/eclim-test
SOLUTION: I was trying to create a project in a dir where I had already created another project... that is not allowed!

** COMPANY (autocompletion)

INSTALL FROM MELPA:
company
company-emacs-eclim-setup

** javadoc-lookup (install from melpa)

Displays javadoc in web browser...

M-x javadoc-lookup       --- lookup class under point, or browse classes
M-x javadoc-add-import   --- add import statement with interactive completion
M-x javadoc-sort-imports --- alphabetically sort import statements in buffer

...add key-binding...
(global-set-key (kbd "C-h j") 'javadoc-lookup)



ADDING MORE JAVADOCS

An index for the core Java classes (i.e. java.*) is provided built-in...
... adding more docs can be done manually... or with Maven...

... manual...
... point to the root of a library's documentation on your filesystem.
... For example (the first entry here will replace the built-in index):
(javadoc-add-roots "/usr/share/doc/openjdk-8-jdk/api"
                   "~/src/project/doc")

... maven...
... specify an artifact as a sequence of three strings/symbols:
... [groupId artifactId version]. For example:
(javadoc-add-artifacts [org.lwjgl.lwjg lwjgl "2.8.2"]
                       [com.nullprogram native-guide "0.2"]
                       [org.apache.commons commons-math3 "3.0"])
... this feature requires that you have Maven and the command-line unzip
utility installed on your system. The initial fetch is slow but Emacs
will operate from its own cache after that.

* ============================ HELLO WORLD =============================

public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello World!");
    }
}

* ================== DIRECTORY STRUCTURE OF A PROJECT ==================

(DIR) src      # source files
(DIR) build    # class files compile here
(DIR) dist     # jar file and anything else needed to run e.g. copies of external libraries...
(DIR) test     # tests (if you're doing unit testing)
(DIR) doc      # javadoc gets built here
      makefile # or build.xml if you're using ant

* ======================== COMMENTS AND JAVADOC ========================
** basics

// single line comment

/*
 Multi-line comment
*/

/**
 * JAVADOC...
 * 
 * @param
 * @return
 * @throws
 * @deprecated
 * @see
 */

** javdoc general

{@code TEXT}    -->
{@literal TEXT} --> same, but without the code font




... building javadoc... for your program

... using javadoc...

DOWNLOAD JAVA API DOCUMENTATION FOR OFFLINE ACCESS
... download JDK API Documentation as zip file for oracle website (58.34MB at time of writing (March 2016))
... save it where you like (I put it in ~/.java/doc/)
... ... /usr/share/doc/

... where save my own javadoc?

emacs javadoc-lookup
 - install with MELPA
 - in .emacs ---> require javadoc-lookup
 - if you don't want to open it up in an external browser, you can set Emacs to run a text-based browser inside itself. (setq browse-url-browser-function 'browse-url-text-emacs)

** javadoc EXAMPLE

#+BEGIN_SRC java :classname example
/**
 * Returns an Image object that can then be painted on the screen.
 * The url argument must specify an absolute {@link URL}. The name
 * argument is a specifier that is relative to the url argument.
 * <p>
 * This method always returns immediately, whether or not the
 * image exists. When this applet attempts to draw the image on
 * the screen, the data will be loaded. The graphics primitives
 * that draw the image will incrementally paint on the screen.
 *
 * @param  url  an absolute URL giving the base location of the image
 * @param  name the location of the image, relative to the url argument
 * @return      the image at the specified URL
 * @see         Image
 */
 public Image getImage(URL url, String name) {
    try {
        return getImage(new URL(url, name));
    } catch (MalformedURLException e) {
        return null;
    }
 }
#+END_SRC

** code examples in javadoc

INLINE CODE EXAMPLE:
{@code Integer.parseInt("45")}

MULTI-LINE CODE EXAMPLE:
... NOTE: put {@code on a line of it's own...
/**
 * <p>EXAMPLE:
 * <pre>
 * {@code
 *  public static class PrimSetup2DSimple extends SetupHelper<Primitives.Params2D> {
 *
 *      public PrimSetup2DSimple() {
 *          super("2D primitive simple params",
 *                Input.in("dimension 1", 10),
 *                Input.in("dimension 2", 10),
 *                Input.obj("axis", Axis.class,
 *                          Axis.X, Axis.Y, Axis.Z));
 *      }
 *
 *      \@Override
 *      public Primitives.Params2D getParams() {
 *          return new Primitives.Params2D((Integer) getInput(0).getValue(),
 *                                         (Integer) getInput(1).getValue(),
 *                                         (Axis)    getInput(2).getValue());
 *      }
 *  }
 * }
 * </pre>
 * </p>
 */

** javadoc inheritance and re-use

AUTOMATIC RE-USE OF METHOD JAVADOC COMMENTS:

You can avoid re-typing doc comments by being aware of how the Javadoc tool
duplicates (inherits) comments for methods that override or implement other
methods. This occurs in three cases:

    When a method in a class overrides a method in a superclass
    When a method in an interface overrides a method in a superinterface
    When a method in a class implements a method in an interface

In the first two cases, if a method m() overrides another method, The Javadoc
tool will generate a subheading "Overrides" in the documentation for m(), with a
link to the method it is overriding.

In the third case, if a method m() in a given class implements a method in an
interface, the Javadoc tool will generate a subheading "Specified by" in the
documentation for m(), with a link to the method it is implementing.

In all three of these cases, if the method m() contains no doc comments or tags,
the Javadoc tool will also copy the text of the method it is overriding or
implementing to the generated documentation for m(). So if the documentation of
the overridden or implemented method is sufficient, you do not need to add
documentation for m(). If you add any documentation comment or tag to m(), the
"Overrides" or "Specified by" subheading and link will still appear, but no text
will be copied.



MANUAL RE-USE:

This works for methods which override a method in a supertype...
... for other cases, e.g. overriding method in the same class, I know no solution...

/**
 * {@inheritDoc}
 *
 * Additional comments...
 */

** package comments

NOTE: javadoc is not generated for any package which doesn't contain any
classes, even if it does contain sub-packages.

FILENAME: package-info.java

#+BEGIN_SRC java :classname example
/**
 * <p>The BSTPG command line application.</p>
 *
 * @see info.bschambers.blockspace
 * @see info.bschambers.bstpg.testgui
 */
package info.bschambers.bstpg;
#+END_SRC

** javadoc links

link to other class in same doc...
{@link class-name}

link to a method...
{@link package.class#member label}

link to class in a different doc...
...

link to external web page (use normal html link)...
See <a href="http://groversmill.com/">Grover's Mill</a> for a history of the Martian invasion.

** HTML in javadoc

todo...

* ========================= IMPORT STATEMENTS ==========================

import info.bschambers.blockspace.util.Pt3D;
// import the class Pt3D

import info.bschambers.blockspace.build.Primitives.Axis;
// import a static inner class

import static info.bschambers.blockspace.TestUtil.*;
// import all static members from TestUtil... this means that you can use static methods and classes directly

// import statements are not necessary if you use the full class path...
java.util.Random rand = new java.util.Random();
// ... this can sometimes be useful to avoid namespace clashes...

* ============================= DATA TYPES =============================

int      - 32 bit integer
long     - 64 bit integer
short    - 16 bit integer
byte     - 8  bit
double   - 64 bit floating point
float    - 32 bit floating point
boolean
char     - 16 bit

** NUMBER LITERALS
Automatic widening conversion is performed on primitives...
... shortening must be done with an explicit cast...

100    // integer
100L   // long
100.0  // double
100.0d // double
100.0f // float
0x3f   // hexadecimal
017    // octal (leading 0 --> this evaluates to 9)
0b1001 // binary (this evaluates to 9)
1_000_000 // underscores to improve readability

** BIGDECIMAL

Use this for accurate floating point numbers and calculations...
... also useful for rounding operations...

!!!!!!!!!!!!!!!!!!!!!!!!EXPLAIN!!!

import java.math.BigDecimal;
import java.math.RoundingMode;

BigDecimal bd = new BigDecimal(5);

bd.compareTo(new BigDecimal(5));

bd.equals(new BigDecimal(5));

// rounding to specified number of decimal places...
BigDecimal bd = new BigDecimal(302.53921);
BigDecimal rounded = bd.setScale(2, RoundingMode.HALF_UP); // result is 302.54

double d = rounded.doubleValue();

* ========================= BITWISE OPERATIONS =========================

byte   - 8 bits
short  - 16 bits
int    - 32 bits
long   - 64 bits

float  - 32 bits
double - 64 bits

char   - 16 bits (unsigned) representing UTF-16 codes



  &  // bitwise AND
. |  // bitwise OR
  ^  // bitwise XOR
  << // left shift  (0b110 << 2 == 0b11000 == 24)
  >> // right shift (0b110 >> 1 == 0b11    == 3)

  ~  // bitwise inversion ((byte) ~0b00001001 == (byte) 0b11110110)



// get the value of a specific bit...
// ... use >> to right-shift the bit you want to the end, then do AND against 1...
// ... will return 1 if both are 1, otherwise 0
// (22 in binary is 10110)
22 >> 0 & 1 // return 0
22 >> 1 & 1 // return 1
22 >> 2 & 1 // return 1
22 >> 3 & 1 // return 0
22 >> 4 & 1 // return 1


// print out a number in binary notation
// doing byte here (hence 8 bits) but would work for any data type
public void printByte(byte b) {
  System.out.print("decimal: " + b + " binary: ");
  for (int i = 0; i < 8; i++)
    System.out.print(b >> (7 - i) & 1);
  System.out.println();
}


// split binary representation of an int into parts and make each one into a byte
int code = 0b1111_0000_1010_1001_0110_0110; // 15772006
// have to cast to avoid error due to lossy conversion...
byte b1 = (byte) (code >> 16); // first 8 bits (I used 24 binary places)
byte b2 = (byte) (code >> 8);
byte b3 = (byte) code;         // last 8 bits
printByte(b1); // "decimal: -6 binary: 11110000"
printByte(b2); // "decimal: -87 binary: 10101001"
printByte(b3); // "decimal: 102 binary: 01100110"

// BIT MASKS




// REPRESENTING BINARY NUMBERS

int i1 = 0b101010100001;
int i2 = Integer.parseInt("101010100001", 2); // same number

byte b1 = 0b111_1111; // 127
byte b1 = -0b111_1111; // -127
byte b1 = Byte.parseByte("-1111111", 2); // -127

// this will cause an error!
// although byte has 8 bits, the first one is used for the sign...
byte b1 = 0b1111_1111;
// ... however, I can force it by casting...
byte b1 = (byte) 0b1111_1111;

* ============================== OBJECTS ===============================

// minimal class...
public class MyClass {
    // field, constructor, and
    // method declarations
}

// more elaborate class...
public class MyClass extends MySuperClass implements YourInterface {
    // fields
    private int i = 0;
    // constructor
    public MyClass(int i) {
        this.i = i;
    }
    // method declarations
    public int getI() { return i; }
}

* ======================= LOOPING AND ITERATION ========================

// standard for loop
for (int i = 0; i < array.length; i++) {
    System.out.println("Array element " + i + " = " + array[i]);
}

// foreach
// ... works on arrays, and on any class which implements Iterable e.g. Lists...

String[] someStr = new String[]{ "hello", "goodbye", "hello again!" };

for (String item : someStr) {
    System.out.println(item);
}

// this is effectively the same as above:
for(Iterator<String> i = someStr.iterator(); i.hasNext(); ) {
    String item = i.next();
    System.out.println(item);
}


** break from nested loop

// can use a label to specify which loop to break...
mainLoop:
while (goal <= 100) {
   for (int i = 0; i < goal; i++) {
      if (points > 50) {
         break mainLoop;
      }
      points += i;
   }
}

** ITERATORS

import java.util.Iterator;

Iterator<T>
public boolean hasNext()
public T next()
public void remove() // OPTIONAL: throw new UnsupportedOperationException



// to use class in for-each loop, must implement Iterable<T>...
public Iterator<T> iterator()

* ========================== SWITCH STATEMENT ==========================

... Switch works with byte, short, char, and int primitive data types. It also
works with enumerated types (see Enum) the String class, and a few special
classes that wrap certain primitive types: Character, Byte, Short, and Integer.

// EXAMPLE: Note use of fall-through behaviour to make a more concice block of code - all matching cases are executed until 'break' is encountered (in this case any int will only match one case).
int month = 8;
String monthString;
switch (month) {
    case 1:  monthString = "January";
    case 2:  monthString = "February";
    case 3:  monthString = "March";
    case 4:  monthString = "April";
    case 5:  monthString = "May";
    case 6:  monthString = "June";
    case 7:  monthString = "July";
    case 8:  monthString = "August";
    case 9:  monthString = "September";
    case 10: monthString = "October";
    case 11: monthString = "November";
    case 12: monthString = "December";
        break;
    default: monthString = "Invalid month";
        break;
}
System.out.println(monthString); // will print out "August"

* ==== CLASS CASTING ===================================================

int num = (int) 32.7429; // cast double into int

* ==== GENERICS ========================================================
Generics enable types (classes and interfaces) to be parameters when defining classes, interfaces and methods.

//
class Flipper<T> implements Iterable<T> {
    private T thing;
    public Flipper(T thing) {
        this.thing = thing;
    }
    public void replace(T item) {
        thing = item;
    }
    public T get() { return thing; }
}

// instatiating the class... note: using the diamond operator to save typing the generic type twice...
Flipper<String> newFlip = new Flipper<>("yahoo");

** extending generics

// Generic type can be BlockSet, or any sub-type of BlockSet...
public abstract class Formatter<T extends BlockSet> {}

// Extends generic class with specified type...
// ... therefore becoming non-generic...
public class BasicFormatter extends Formatter<BasicBlockSet> {}

** generic methods
Example of a generic static method (in a non-generic class)...
... returns random item from an array...

public class Misc {
    public static <T> T chooseRandom(T[] items) {
        return items[(int) (Math.random() * items.length)];
    }
}


//// INVOCATION:

// type inference means that you don't need to specity the generic type at invocation...
JoinMethod jm = Misc.chooseRandom(joiners);

// this is also valid, but not neccessary
JoinMethod jm = Misc.<JoinMethod>chooseRandom(joiners);

* ========================= DATA STRUCTURES ==========================

** ARRAYS

NOTE: arrays are a special case which are not so object-oriented as most of java

// define an array literal
String[] strings = new String[]{ "hello", "goodbye", "hello again!" };

*** USEFUL ARRAY METHODS

// low level method for copying arrays...
// ... this will be the fastest way to copy an array...
void System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length)


import java.util.Arrays;
Arrays.copyOf(T[] original, int newLength)
Arrays.copyOfRange(T[] original, int from, int to)
Arrays.fill ...
Arrays.asList ...

Arrays.toString(array); // nice for printing an array



// These all return a new array, with no side effects for the input array
import com.benchambers.bsutil.BSArrays;
BSArrays.reverse(T[] array)
BSArrays.addItemAt(T[] array, int index, T item)
BSArrays.removeItemAt ...
BSArrays.prepend ...
BSArrays.append ...
BSArrays.concat ...
BSArrays.concat ... // varargs version

*** SORTING ARRAYS:

static void java.util.Arrays.sort()
- sorts in place
- guaranteed stable sort for Objects (probably doesn't matter for primitives)

// sort using default ordering
Arrays.sort(myArray);

// sort with a comparator
Arrays.sort(myArray, myComparator);

// sort part of an array
Arrays.sort(myArray, startIndex, endIndex, optionalComparator);

**** COMPARATOR SORT EXAMPLE:

public class Two {
       public int a;
       public int b;
       public Two(int a, int b) {
       	      this.a = a;
	      this.b = b;
       }
}

public class DistComparator implements Comparator {
       private int dist(Two t) { return Math.max(t.a, t.b) - Math.min(t.a, t.b); }
       /** @return negative num = less than, zero = equal, positive num = greater than. */
       public int compare(Two t1, Two t2) { return dist(t1) - dist(t2); }
}

Two[] twoArray = new Two[] { new Two(1,23), new Two(9,5), new Two(98,110), new Two(-13,-15) };

Arrays.sort(twoArray, new DistComparator());

** THE COLLECTIONS INTERFACE

// TO ARRAY
// ... must pass in an array of the correct size and type...
// ... otherwise the array will be type Object...
String[] newArray = new String[list.size()];
String[] strArray = list.toArray(newArray);

// NOTE: look into all the methods available through the Collections interface... (reverse etc...)
Collections.reverse(myCollection); // reverses in place

** LIST
import java.util.ArrayList;
List<String> list = new ArrayList<>();
list.add("New String");
list.get(0); // retrieve first item

** SET
import java.util.Set;
import java.util.HashSet;
Set<String> set = new HashSet<String>();
set.add("dingle") // returns true (item added)
set.add("fink")   // returns true (item added)
set.add("dingle") // returns false (item NOT added)
set.size()        // returns 2 (set cannot contain duplicates)

** MAP
Equivalent to dictionary or hashtable in some other languages.
Maps keys to values.
A map cannot contain duplicate keys; each key can map to at most one value.

Map<K, V>
... add and retrieve using PUT and GET...

// example mapping command names to actions
import java.util.HashMap;
Map<String, Runnable> commands = new HashMap<>();
commands.put("greet", () -> System.out.println("hello"));
Runnable cmd = commands.get("greet");

** HASHTABLE vs HASHMAP

HashTable is a legacy class... GENERALLY BETTER TO USE HASHMAP.

Hashtable is synchronized, whereas HashMap is not. This makes HashMap better for
non-threaded applications, as unsynchronized Objects typically perform better
than synchronized ones.

Hashtable does not allow null keys or values. HashMap allows one null key and
any number of null values.

One of HashMap's subclasses is LinkedHashMap, so in the event that you'd want
predictable iteration order (which is insertion order by default), you could
easily swap out the HashMap for a LinkedHashMap. This wouldn't be as easy if you
were using Hashtable.

* ==== ENUMS ===========================================================

An enum type is a special data type that enables for a variable to be
a set of predefined constants. The variable must be equal to one of
the values that have been predefined for it. Common examples include
compass directions (values of NORTH, SOUTH, EAST, and WEST) and the
days of the week.

Because they are constants, the names of an enum type's fields are in
uppercase letters.

** SIMPLE EXAMPLE
public enum Day {
    SUNDAY, MONDAY, TUESDAY, WEDNESDAY,
    THURSDAY, FRIDAY, SATURDAY
}

** ITERATE OVER ENUMS
for (Day d : Day.values())
    System.out.println("Day: " + d);

** MORE COMPLEX EXAMPLE (with fields and methods)
//  enums can have parameters and methods... this one even has a main method, so
// it can be run as a standalone program!
public enum Planet {
    MERCURY (3.303e+23, 2.4397e6),
    VENUS   (4.869e+24, 6.0518e6),
    EARTH   (5.976e+24, 6.37814e6),
    MARS    (6.421e+23, 3.3972e6),
    JUPITER (1.9e+27,   7.1492e7),
    SATURN  (5.688e+26, 6.0268e7),
    URANUS  (8.686e+25, 2.5559e7),
    NEPTUNE (1.024e+26, 2.4746e7);

    private final double mass;   // in kilograms
    private final double radius; // in meters
    Planet(double mass, double radius) {
        this.mass = mass;
        this.radius = radius;
    }
    private double mass() { return mass; }
    private double radius() { return radius; }

    // universal gravitational constant  (m3 kg-1 s-2)
    public static final double G = 6.67300E-11;

    double surfaceGravity() {
        return G * mass / (radius * radius);
    }
    double surfaceWeight(double otherMass) {
        return otherMass * surfaceGravity();
    }
    public static void main(String[] args) {
        if (args.length != 1) {
            System.err.println("Usage: java Planet <earth_weight>");
            System.exit(-1);
        }
        double earthWeight = Double.parseDouble(args[0]);
        double mass = earthWeight/EARTH.surfaceGravity();
        for (Planet p : Planet.values())
           System.out.printf("Your weight on %s is %f%n",
                             p, p.surfaceWeight(mass));
    }
}

* ==== VARARGS =========================================================

//  Varargs are converted into an array, so you use them exactly as you would use
// an array...

//
public void printAll(String ... strings) {
    for (String s : strings)
        System.out.println(s);
}

// mixing varargs with regular argument...
public double min(double first, double ... rest) {
    double min = first;
        for (double num : rest)
            if (num < min)
                min = num;
    return min;
}

* ==== ASSERTIONS ======================================================

Assertions are boolean expressions which verify assumptions that we
make within code we develop. If the expression is false, the program
will terminate and report an error message. For example, suppose that
you have a computed value that you might use to index into an
array. If this value were negative, it would cause an
ArrayIndexOutOfBoundsException sometime later. But if you write the
code

    assert index >= 0;

you can pinpoint the place where the error occurred. By default,
assertions are disabled.You can enable them from the command line by
using the -enableassertions flag (-ea for short). Assertions are for
debugging: your program should not rely on assertions for normal
operation since they may be disabled.

* ==== STRING METHODS ==================================================

String str = "hello!"; // string literal
String str2 = new String(str); // new constructor makes a copy of the input string

int len = str2.length()

boolean b = str.contains("hell"); // true
String s = str.replace("hell", "flipp");
String s = str.trim(); // gets rid of trailing whitespace at beginning and end
String[] parts = str.split("l"); // returns { "he", "", "o!" } --> NOTE: input is a REGEX

// sub-strings
String c = "abc".substring(2,3);
String d = cde.substring(1, 2);

"bingo bingo".indexOf('n'); // starting from 0
"bingo bingo".indexOf('n', 3); // starting from index 3

// programatically build a string filled with 10 dollar signs...
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 10; i++) sb.append('$');
String s = sb.toString();

// regular expression methods (SEE BELOW)
boolean b = str.matches(REGEX);
boolean b = str.replaceFirst(REGEX);
boolean b = str.replaceAll(REGEX);

** FORMAT
// SEE ALSO: System.out.format()
// SEE ALSO: System.out.printf()
// SEE ALSO: java.text.DecimalFormat
String s = String.format("A few format codes used --> string:%s number:%d", str, num);

// A FEW FORMAT SPECIFIERS (full documentation SEE: java.util.Formatter)
%s --- string
%d --- decimal
%f --- floating point number (with 6 decimal places)
%n --- newline

// MORE ADVANCED...
%s      --- string, as many chars as needed
%15s    --- string, 15 chars (right-justify)
%-15s   --- string, 15 chars (left-justify)
%d      --- integer, as many digits as needed
%4d     --- integer, 4 digits (pad with spaces)
%04d    --- integer, 4 digits (pad with zeroes)
%f      --- float, as many digits as needed (6 decimal places)
%.2f    --- float, 2 decimal places
%10.2f  --- float, 2 decimal places, whole string occupies 10 chars

** TRICKS AND TECHNIQUES

// way to find number of occurences of a char
// or combinded length of all occurences of a substring
// ... find number of full stops in str:
str.length() - str.replace(".", "").length()

* ==== REGULAR EXPRESSIONS =============================================

// QUICK EXAMPLE
import java.util.regex.Pattern;
import java.util.regex.Matcher;
Pattern p = Pattern.compile(""); // regex
Matcher m = p.matcher(""); // string to search
while (m.find()) {
    System.out.format("Found the text \"%s\" starting at " +
                      "index %d and ending at index %d.%n",
                      m.group(), m.start(), m.end());
}

// EXAMPLES:
// note: backslash has to be escaped in string...
"^(\\d+)" --> first group matches one or more digits at beginning of string



REPRESENTATION OF REGEX:

A Pattern object is a compiled representation of a regular expression. The
Pattern class provides no public constructors. To create a pattern, you must
first invoke one of its public static compile methods, which will then return a
Pattern object. These methods accept a regular expression as the first argument;
the first few lessons of this trail will teach you the required syntax.

A Matcher object is the engine that interprets the pattern and performs match
operations against an input string. Like the Pattern class, Matcher defines no
public constructors. You obtain a Matcher object by invoking the matcher method
on a Pattern object.

A PatternSyntaxException object is an unchecked exception that indicates a
syntax error in a regular expression pattern.



METACHARACTERS

<([{\^-=$!|]})?*+.>

TREAT METACHARACTERS AS ORDINARY CHARACTERS
BACKSLASH ESCAPE: \.
QUOTE (\Q and \E to start and end quote): \Q<html>\E

CHARACTER CLASSES
[abc]           a, b, or c (simple class)
[^abc]          Any character except a, b, or c (negation)
[a-zA-Z]        a through z, or A through Z, inclusive (range)
[a-d[m-p]]      a through d, or m through p: [a-dm-p] (union)
[a-z&&[def]]    d, e, or f (intersection)
[a-z&&[^bc]]    a through z, except for b and c: [ad-z] (subtraction)
[a-z&&[^m-p]]   a through z, and not m through p: [a-lq-z] (subtraction)

PREDEFINED CHARACTER CLASSES
. 	Any character (may or may not match line terminators)
\d 	A digit: [0-9]
\D 	A non-digit: [^0-9]
\s 	A whitespace character: [ \t\n\x0B\f\r]
\S 	A non-whitespace character: [^\s]
\w 	A word character: [a-zA-Z_0-9]
\W 	A non-word character: [^\w]



QUANTIFIERS

Greedy 	Reluctant  Possessive  Meaning
X?      X??        X?+         X, once or not at all
X*      X*?        X*+         X, zero or more times
X+      X+?        X++         X, one or more times
X{n}    X{n}?      X{n}+       X, exactly n times
X{n,}   X{n,}?     X{n,}+      X, at least n times
X{n,m}  X{n,m}?    X{n,m}+     X, at least n but not more than m times



OR
(true|false)



MATCHING GROUPS
parentheses () also create groups, which can be referenced later...
(true|false)
(?:true|false)   ?: prevents group from being captured
... groups are indexed from 1 (group 0 is the WHOLE match)



BOUNDARY MATCHERS
^    The beginning of a line
$    The end of a line
\b   A word boundary
\B   A non-word boundary
\A   The beginning of the input
\G   The end of the previous match
\Z   The end of the input but for the final terminator, if any
\z   The end of the input

* ==== OBJECT COMPARISON ===============================================

boolean x = 3 == 1 + 2; // true

boolean x = "hello" == "hello"; // FALSE: String is an Object - for Objects, '==' compares references i.e. only returns true for identical object references
String str = "hello";
boolean x = str == str; // true

==== USE equals() TO COMPARE OBJECTS ====
... default behaviour of equals() is same as '=='

boolean x = "hello".equals("hello"); // true

// to compare your own objects, you must override equals()
public class Thing {
    private int num;
    public Thing(int num) {
        this.num = num;
    }

    @Override
    public boolean equals(Object x) {
        if (!(x instanceof Thing)) { return false; }
        return this.num == (Thing) x.num;
    }

    /**
     WARNING: equal objects must have equal hash codes. Therefore,
     when overriding the equals method, you must also override the
     hashCode method. Failure to do so violates the general contract
     for the hashCode method, and any classes that use the hash code,
     such as HashMap will not function properly!
     SEE BELOW...
    */
    @Override
    public int hashCode() {
        // Technique informed by

    }
}

** example from Princeton Algorithms Part 1 (coursera)

// equals() in a custom IMMUTABLE data type...

// NOTE: class is final - typically unsafe to use equals() with inheritance (would violate symmetry)
public final class Date implements Comparable<Date> {
   private final int month;
   private final int day;
   private final int year;
   ...

   @Override
   public boolean equals(Object y) {

      // some safe optimizations
      if (y == this) return true;
      if (y == null) return false;
      if (y.getClass() != this.getClass()) return false;

      // cast guaranteed to succeed here
      Date that = (Date) y;

      // test for equality in all significant fields
      if (this.day   != that.day  ) return false;
      if (this.month != that.month) return false;
      if (this.year  != that.year ) return false;
      return true;
   }
}

** CLASS COMPARISON

// direct comparison of CLASSES (true if classes are identical)
class1 == class2
object1.getClass() == object2.getClass()

// test whether an OBJECT is an instance of CLASS or SUBCLASS of it
object1 instanceof Class1

// test whether a CLASS is a subclass of another (also true if they are identical)
SuperClass.isAssignableFrom(ChildClass)
object1.getClass().isAssignableFrom(object2.getClass())

* ==== HASH/HASHCODE ===================================================

** OVERRIDING HASHCODE

for nearly all cases reasonable good implementation was proposed in Josh Bloch's Effective Java in item 8. The best thing is to look it up there because the author explains there why the approach is good.
A short version

    Create a int result and assign a non-zero value.

    For every field f tested in the equals() method, calculate a hash code c by:
        If the field f is a boolean: calculate (f ? 0 : 1);
        If the field f is a byte, char, short or int: calculate (int)f;
        If the field f is a long: calculate (int)(f ^ (f >>> 32));
        If the field f is a float: calculate Float.floatToIntBits(f);
        If the field f is a double: calculate Double.doubleToLongBits(f) and handle the return value like every long value;
        If the field f is an object: Use the result of the hashCode() method or 0 if f == null;
        If the field f is an array: see every field as separate element and calculate the hash value in a recursive fashion and combine the values as described next.

    Combine the hash value c with result:

    result = 37 * result + c

    Return result

This should result in a proper distribution of hash values for most use situations.
shareimprove this answer

edited Jun 22 '15 at 5:41
Josh Hinman
4,65362642

answered Sep 22 '08 at 7:22
dmeister
15.9k135477

23

Yeah I'm particularly curious about where the number 37 comes from. – Kip Sep 22 '08 at 17:25
5

I'm not aware of any proof. The number of 37 is arbitrary, but it should be prime. Why? I'm not really sure but it has to do with modulo arthritics and properties of prime numbers which lead to go distributions. – dmeister Sep 22 '08 at 23:55
13

I used item 8 of Josh Bloch's "Effective Java" book. – dmeister Oct 4 '10 at 14:39
13

@dma_k The reason for using prime numbers and the method described in this answer is to ensure that the computed hashcode will be unique. When using non-prime numbers, you cannot guarantee this. It does not matter which prime nummer you choose, there is nothing magical about the number 37 (too bad 42 isn't a prime number, eh?) – Simon Forsberg Feb 15 '13 at 13:58
16

@SimonAndréForsberg Well, computed hash code cannot be always unique :) Is a hashcode. However I got the idea: the prime number has only one multiplier, while non-prime has at least two. That creates an extra combination for multiplication operator to result the same hash, i.e. cause collision. – dma_k Feb 15 '13 at 14:08

* ==== DEEP COPY OF OBJECT =============================================
... DON'T override Object.clone() (see internet for reasons)

... Make a copy constructor for the class:
public Thing(Thing original) {
    // make copies of all variables...
    // ... make sure that no references are shared!
}

* ==== GUI =============================================================

** awt (Abstract Windowing Toolkit)

The original java GUI library...
... some parts are still used by swing application e.g. java.awt.event...

** swing
*** LAYOUT MANAGERS

    BorderLayout
    BoxLayout
    CardLayout
    FlowLayout
    GridBagLayout
    GridLayout

mainly used by automatic GUI-builder tools:
    GroupLayout
    SpringLayout

*** KEY BINDINGS
// JFrame - keyboard shortcut to exit program...
// NOTE: the methods getInputMap and getActionMap belong to JComponent...
// ... since JFrame is not a JComponent we get the root-pane...
String exitKey = "tpgExitProgram";
KeyStroke exitStroke = KeyStroke.getKeyStroke(KeyEvent.VK_Q, InputEvent.CTRL_DOWN_MASK);
Action exitAction = GUI.action("exit program", "", () -> tpgExitProgram());
JRootPane rp = getRootPane();
rp.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(exitStroke, exitKey);
rp.getActionMap().put(exitKey, exitAction);
** JavaFX (to replace swing)

April 2017: javaFX not included as part of openjdk...
... had to install openjfx separately...
$ sudo apt-get install openjfx

** GUI GOTCHAS
*** alignment of a JLabel (probably applies to other components also)
see /home/bsc/ComputerWork/PROJECTS/bstpg/TESTGUI/src/main/java/info/bschambers/bstpg/testgui/TPGListChooserDialog.java

* ========================== FILE OPERATIONS ===========================

packages:
java.io
java.nio

** READ A FILE
import java.util.List;
import java.nio.file.Files;
import java.io.File;
import java.io.IOExeption;

try {
   List<String> lines = Files.readAllLines(new File("social_network_timestamps").toPath());
   System.out.println("... " + lines.size() + " lines in file");
} catch (IOException e) {}

** WRITE A FILE
import java.io.FileWriter;
import java.io.IOExeption;

String newline = System.getProperty("line.separator");
boolean append = true;
try {
    FileWriter writer = new FileWriter(file, append);
    writer.write("A new line in my file." + newline);
    writer.close();
} catch (IOException e) {}

** FILE OBJECTS

import java.io.File;

String homeDirStr = System.getProperty("user.home");

File homeDir = new File(homeDirStr);

homeDir.isDirectory(); // true
homeDir.isFile();      // false (it's a directory)
homeDir.exists();      // true

File f1 = new File("file1.txt");
File f2 = new File(homeDir, "file2.txt");
File f3 = new File(homeDirStr, "file3.txt");

File f = new File(".humbug", "log.txt");
f.getParentFile().mkdirs(); //
boolean b = f.createNewFile(); // return true if file is created
boolean b = f.delete() // return true if file is deleted

// getting part of a file...
String str = f.getName(); // the last part of the path
String str = f.getParent();
File p = f.getParentFile();

** PROPERTIES FILE/CONFIGURATION FILE

import java.util.Properties;
import java.io.InputStream;
import java.io.FileInputStream;
import java.io.IOException;

Properties props = new Properties();
InputStream input = null;

try {

    input = new FileInputStream("bstpg-config");
    props.load(input);

    showProperty(props, "emailNotificationAddr", "default-addr");
    showProperty(props, "testString", "default-str");
    showProperty(props, "teapotVol", "default-vol");
    showProperty(props, "cupVol", "default-vol");

} catch (IOException ex) {
    ex.printStackTrace();
}

** OTHER USEFUL THINGS

File.separator // the system dependent file-path separator
String newline = System.getProperty("line.separator");

* ========================= EXCEPTION HANDLING =========================
** THROW AN EXCEPTION
throw new NullPointerException("optional message string");

** TRY CATCH FINALLY

try {
    Dingle.dangerousMethod();
} catch (NullPointerexception e) {
    System.out.println("caught " + e);
} catch (Exception e) {
    System.out.println("caught " + e);
    e.printStackTrace();
} finally {
    // always do this, no matter whether we caught exceptions or not
    Dingle.cleanup();
}

** WRITING CUSTOM EXCEPTION

extend one of these
... java.lang.Exception
... java.lang.RuntimeException
... or any other Exception...

EXAMPLE:
public static class UnrecognisedBlockException extends RuntimeException {
    public UnrecognisedBlockException(Block b) {
        super("block type not recognised: " + b);
    }
}

* ======================= COMPILER ANNOTATIONS =======================

@Override
... compiler throws an exception if the overriden method is not detected in
one of the superclasses.

@SuppressWarnings("unchecked")
... suppress specified type of compiler warning.
... only do this if you can be ABSOLUTELY sure that the method is safe
... always write a comment explaining WHY you think it's safe
VARIETIES:
... "unchecked": unchecked class-cast
... "rawtypes": e.g. warning: [rawtypes] found raw type: ArrayList
COMBINING MULTIPLE SUPPRESSWARNINGS:
@SuppressWarnings({"rawtypes", "unchecked"})

@Deprecated
... also, use the @deprecated javadoc tag to tell developers what to use instead.

@SafeVarargs
... prevents warning from being issued about "Possible heap pollution
from parameterized vararg"...
... only use this once you have very carefully confirmed that there is
no danger that your method will assign an incorrect data type and
therefore of unexpected ClassCastException

* ===================== ANONYMOUS INNER CLASSES ======================

interface Spangler {
    public void spangle();
}

// using interface in an anonymous inner class...
methodWhichTakesASpangler(new Spangler() {
        public void spangle() {
            System.out.println("SPANGLE!");
        }
    });

// same thing using lambda...
methodWhichTakesASpangler(() -> System.out.println("SPANGLE!"));

* ========== FUNCTIONAL INTERFACES/LAMBDA/METHOD REFERENCES ==========
** introduction
Instead of using
ANONYMOUS CLASS
... you can use
LAMBDA EXPRESSION
... And if this just calls one method, you can use
METHOD REFERENCE

... all of these may be used in conjunction with FUNCTIONAL INTERFACES...

** lambda example

interface Operation {
    public int execute(int x, int y);
}

public void printOp(Operation op, int x, int y) {
    System.out.println("RESULT: " + op.execute(x, y));
}

jshell> printOp((int x, int y) -> x + x + y, 5, 3);
RESULT: 13

** STANDARD FUNCTIONAL INTERFACES

EXAMPLE:

import java.util.function.Predicate;

interface Predicate<T> {
    // take item of type T and return a boolean
    boolean test(T item);
}



... some other functional interfaces...
... look at java.util.function documentation for more...

| class signature     | functional method | returns          | notes                                              |
|---------------------+-------------------+------------------+----------------------------------------------------|
| java.lang.Runnable  | run()             | void             |                                                    |
|                     |                   |                  |                                                    |
| Function<T, R>      | apply(T)          | object of type R |                                                    |
| BiFunction<T, U, R> | apply(T, U)       | object of type R |                                                    |
|                     |                   |                  |                                                    |
| UnaryOperator<T>    | apply(T)          | object of type T |                                                    |
| BinaryOperator<T>   | apply(T, T)       | object of type T |                                                    |
|                     |                   |                  |                                                    |
| Supplier<T>         | get()             | object of type T |                                                    |
| BooleanSupplier<T>  | getAsBoolean()    | boolean          | interfaces provided for other primitive types also |
|                     |                   |                  |                                                    |
| Consumer<T>         | accept(T)         | void             |                                                    |
| BiConsumer<T, U>    | accept(T, U)      | void             |                                                    |
|                     |                   |                  |                                                    |
| BiPredicate<T,  U>  | test(T,  U)       | boolean          |                                                    |

** method references

There are four types of method references:

*** reference to a static method

// lambda equivalent
(args) -> Class.staticMethod(args)

// method reference
Class::staticMethod

// functional interface usage
Function<Double, Double> func = Frobnicator::transformValue;
double d = func.apply(36.3);

*** reference to an instance method of an object of a particular type.

// lambda equivalent
(obj, args) -> obj.instanceMethod(args)

// method reference
ObjectType::instanceMethod

// functional interface usage:
// ... the object instance is first parameter of the functional interface...
Person bill = new Person("William Higgins", 45);
Function<Person, Integer> func = Person::getAge;
int age = func.apply(bill);

// ... function with an argument...
BiFunction<Person, String, String> func = Person::getResponse;
String reply = func.reply(bill, "hello");

*** reference to an instance method of an existing object

Splok b = new Splok();
b::foo; // method reference to the foo method of Splok instance b

*** reference to a constructor

NO-ARGS CONSTRUCTOR:

// lambda equivalent
() -> new ClassName()

// method reference
ClassName::new


CONSTRUCTOR WITH ARGS:

// lambda equivalent
(args) -> new ClassName(args)

// method reference...
ClassName::new

// functional interface usage:
// ... think of it as a function which takes argument of ArgClassName and returns ClassName...
Function<ArgClassName, ClassName> constructor = ClassName::new;
ClassName blah = constructor.apply(new ArgClassName());

**** contructor reference examples

#+BEGIN_SRC java :classname example
// no args constructor
import java.util.function.Function;
import java.util.function.Supplier;

// no-args constructor
Supplier<BuildComponents> noArgsConstructor = Teapot.Components::new;
BuildComponents comp = noArgsConstructor.get();

// teapot-automator constructor takes Environment as argument
Function<Environment, Automator> envConstructor = Teapot::new;
Automator auto = envConstructor.apply(getEnvironment());

#+END_SRC

** EXAMPLE (compare anonymous class/lambda/method reference)

#+BEGIN_SRC java :classname example

class Shipment {
  public double calculateWeight() {
    double weight = 0;
    // Calculate weight
    return weight;
  }

  public List<Double> calculateOnShipments(List<Shipment> l, Function<Shipment, Double> f) {
    List<Double> results = new ArrayList<>();
    for(Shipment s : l) {
      results.add(f.apply(s));
    }
    return results;
  }
}

// We can call that method using:

List<Shipment> l = new ArrayList<Shipment>();

// Using an anonymous class
calculateOnShipments(l, new Function<Shipment, Double>() {
  public Double apply(Shipment s) { // The object
    return s.calculateWeight(); // The method
  }
});

// Using a lambda expression
calculateOnShipments(l, s -> s.calculateWeight());

// Using a method reference
calculateOnShipments(l, Shipment::calculateWeight);

#+END_SRC

* =========================== RANDOM NUMBERS ===========================

Math.random() // random double between 0 (inclusive) and 1 (exclusive)

import java.util.Random;
Random rand new Random();
rand.nextInt();   // a random int
rand.nextInt(10); // a random int between 0 and 9

* ========== SERIALIZATION: loading and saving java objects ==========
** introduction
USE EITHER:
... built in interface java.io.Serializable
... ...
... JSON (JavaScript Object Notation)
... ... text-based (human-readable)



To serialize an object means to convert its state to a byte stream so that the
byte stream can be reverted back into a copy of the object.

A Java object is serializable if its class or any of its superclasses implements
either the java.io.Serializable interface or its subinterface,
java.io.Externalizable.

Deserialization is the process of converting the serialized form of an object
back into a copy of the object.

** java.io.Serializable

SIMPLE EXAMPLE:

#+BEGIN_SRC java
import javax.naming.*;
import java.util.Hashtable;
import java.awt.Button;

/**
  * Demonstrates how to bind a Serializable object to a directory.
  * (Use Unbind to remove binding.)
  *
  * usage: java SerObj
  */

class SerObj {
    public static void main(String[] args) {

	// Set up environment for creating initial context
        Hashtable<String, Object> env = new Hashtable<String, Object>(11);
	env.put(Context.INITIAL_CONTEXT_FACTORY,
	    "com.sun.jndi.ldap.LdapCtxFactory");
	env.put(Context.PROVIDER_URL, "ldap://localhost:389/o=JNDITutorial");

	try {
	    // Create the initial context
	    Context ctx = new InitialContext(env);

	    // Create object to be bound
	    Button b = new Button("Push me");

	    // Perform bind
	    ctx.bind("cn=Button", b);

	    // Check that it is bound
	    Button b2 = (Button)ctx.lookup("cn=Button");
	    System.out.println(b2);

	    // Close the context when we're done
	    ctx.close();
	} catch (NamingException e) {
	    System.out.println("Operation failed: " + e);
	}
    }
}
#+END_SRC

MAKING CUSTOM CLASSES SERIALIZABLE:
Two conditions must be met:
- class must implement the java.io.Serializable.
- all fields must be serializable.
  - if a field is not serializable, it must be marked transient.

#+BEGIN_SRC java
public class Employee implements java.io.Serializable {
   public String name;
   public String address;
   public transient int SSN;
   public int number;
   public void mailCheck() {
      System.out.println("Mailing a check to " + name + " " + address);
   }
}
#+END_SRC

** JSON
*** com.google.gson

handles POJO (Plain Old Java Object) automatically using get/set methods

custom 

#+BEGIN_SRC java
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

public class GsonTest {

  public static void main(String[] args) {
    GsonBuilder gBuild = new GsonBuilder();
    gBuild.setPrettyPrinting();
    Gson gson = gBuild.create();

    // encode simple class (POJO)
    SimpleThing st = new SimpleThing()
    st.a = 41;
    st.setC(99.991);
    String stJson = gson.toJson(st);

    // encode complex class
    ComplexThing ct = new ComplexThing()
    String ctJson = gson.toJson(ct));

    // decode from json string
    SimpleThing decodecST = gson.fromJson(stJson, SimpleThing.class);
    ComplexThing decodedCT = gson.fromJson(ctJson, ComplexThing.class);
  }

  public class SimpleThing {

    public int a = 12;
    public String b = "bannana";
    private double c = 32.051;

    public double getC() {
      return c;
    }

    public void setC(double val) {
      c = val;
    }
  }

  public class ComplexThing {

  }
}
#+END_SRC

* ==================== INTERFACES/ABSTRACT METHODS =====================

SINCE JAVA 8 INTERFACES CAN DEFINE DEFAULT METHODS

public interface flipper {

    public void flip();

    public default int getFlipAmount() {
        return 1;
    }

}

* =================== MULTITHREADING AND CONCURRENCY ===================
** THREADS AND PROCESSES
*** THREAD
Threads are sometimes called lightweight processes. Both processes and
threads provide an execution environment, but creating a new thread
requires fewer resources than creating a new process.
*** PROCESS
A process has a self-contained execution environment. A process
generally has a complete, private set of basic run-time resources; in
particular, each process has its own memory space.

Processes are often seen as synonymous with programs or
applications. However, what the user sees as a single application may
in fact be a set of cooperating processes. To facilitate communication
between processes, most operating systems support Inter Process
Communication (IPC) resources, such as pipes and sockets. IPC is used
not just for communication between processes on the same system, but
processes on different systems.

Most implementations of the Java virtual machine run as a single
process. A Java application can create additional processes using a
ProcessBuilder object.
** THREAD BASIC USAGE
*** constructing and starting a thread
The most common constructor takes a Runnable - then call start() to start it...

// using lambda
(new Thread(() -> {
        while (true)
            System.out.println("I am rad!");
    })).start();

// using anonymous inner class
(new Thread(new Runnable() {
        @Override public void run() {
            while (true)
                System.out.println("I am rad!");
        }
    })).start();

*** useful Thread methods

// (static method) pauses the currently executing thread for the specified number of milliseconds
try {
    Thread.sleep(1000);
} catch (InterruptedException e) {}

*** interrupts

Interrupt handling must be added by the programmer...

Normally done by catching InterruptedException - add handling code in the catch
clause of the try-catch block - the most common usage is to stop execution of
the thread.

May also do it by periodically testing Thread.interrupted(), this is useful for
when a thread may go a long time without invoking a method which throws
InterruptedException. You can check whether an interrupt message has been
received, and then either handle the interrupt, or the most sensible thing may
be to throw an InterruptedException so that all interrupts can be handled in a
single centralised catch clause.

*** join

// create a new thread called 't' and start it...
Thread t = new Thread(someRunnable);
t.start();

// ... the current thread will pause and wait for 't' to finish executing
t.join();

... join, also takes a long argument, indicating the maximum number of milliseconds to wait

** SYNCHRONISATION/PROGRAMMING FOR CONCURRENCY
*** immutable objects
Use immutable objects as much as possible since they are inherently thread-safe:

guidelines for creating immutable objects:
- Don't provide "setter" methods — methods that modify fields or objects referred to by fields.
- Make all fields final and private.
- Don't allow subclasses to override methods. The simplest way to do this is to declare the class as final. A more sophisticated approach is to make the constructor private and construct instances in factory methods.
- If the instance fields include references to mutable objects, don't allow those objects to be changed:
  - Don't provide methods that modify the mutable objects.
  - Don't share references to the mutable objects. Never store references to external, mutable objects passed to the constructor; if necessary, create copies, and store references to the copies. Similarly, create copies of your internal mutable objects when necessary to avoid returning the originals in your methods.

*** synchronised methods
- First, it is not possible for two invocations of synchronized methods on the
  same object to interleave. When one thread is executing a synchronized method
  for an object, all other threads that invoke synchronized methods for the same
  object block (suspend execution) until the first thread is done with the
  object.
- Second, when a synchronized method exits, it automatically establishes a
  happens-before relationship with any subsequent invocation of a synchronized
  method for the same object. This guarantees that changes to the state of the
  object are visible to all threads.

EXAMPLE
public synchronised void increment() {
    counter++;
}
*** synchronised statements
Another way to create synchronized code is with synchronized statements. Unlike
synchronized methods, synchronized statements must specify the object that
provides the intrinsic lock:

public void addName(String name) {
    synchronized(this) {
        lastName = name;
        nameCount++;
    }
    nameList.add(name);
}

In this example, the addName method needs to synchronize changes to lastName and
nameCount, but also needs to avoid synchronizing invocations of other objects'
methods. (Invoking other objects' methods from synchronized code can create
problems that are described in the section on Liveness.) Without synchronized
statements, there would have to be a separate, unsynchronized method for the
sole purpose of invoking nameList.add.

Synchronized statements are also useful for improving concurrency with
fine-grained synchronization. Suppose, for example, class MsLunch has two
instance fields, c1 and c2, that are never used together. All updates of these
fields must be synchronized, but there's no reason to prevent an update of c1
from being interleaved with an update of c2 — and doing so reduces concurrency
by creating unnecessary blocking. Instead of using synchronized methods or
otherwise using the lock associated with this, we create two objects solely to
provide locks.

public class MsLunch {
    private long c1 = 0;
    private long c2 = 0;
    private Object lock1 = new Object();
    private Object lock2 = new Object();

    public void inc1() {
        synchronized(lock1) {
            c1++;
        }
    }

    public void inc2() {
        synchronized(lock2) {
            c2++;
        }
    }
}

Use this idiom with extreme care. You must be absolutely sure that it really is
safe to interleave access of the affected fields.

*** atomic access and the volatile keyword
An atomic action is one that effectively happens all at once. An atomic action
cannot stop in the middle: it either happens completely, or it doesn't happen at
all. No side effects of an atomic action are visible until the action is
complete.

We have already seen that an increment expression, such as c++, does not
describe an atomic action. Even very simple expressions can define complex
actions that can decompose into other actions. However, there are actions you
can specify that are atomic:

- Reads and writes are atomic for reference variables and for most primitive
  variables (all types except long and double).
- Reads and writes are atomic for all variables declared volatile (including
  long and double variables).

Atomic actions cannot be interleaved, so they can be used without fear of thread
interference. However, this does not eliminate all need to synchronize atomic
actions, because memory consistency errors are still possible. Using volatile
variables reduces the risk of memory consistency errors, because any write to a
volatile variable establishes a happens-before relationship with subsequent
reads of that same variable. This means that changes to a volatile variable are
always visible to other threads. What's more, it also means that when a thread
reads a volatile variable, it sees not just the latest change to the volatile,
but also the side effects of the code that led up the change.

Using simple atomic variable access is more efficient than accessing these
variables through synchronized code, but requires more care by the programmer to
avoid memory consistency errors. Whether the extra effort is worthwhile depends
on the size and complexity of the application.

*** Atomic Variables
The java.util.concurrent.atomic package defines classes that support atomic
operations on single variables. All classes have get and set methods that work
like reads and writes on volatile variables. That is, a set has a happens-before
relationship with any subsequent get on the same variable. The atomic
compareAndSet method also has these memory consistency features, as do the
simple atomic arithmetic methods that apply to integer atomic variables.

EXAMPLE - A SIMPLE COUNTER:

import java.util.concurrent.atomic.AtomicInteger;

class AtomicCounter {
    private AtomicInteger c = new AtomicInteger(0);

    public void increment() {
        c.incrementAndGet();
    }

    public void decrement() {
        c.decrementAndGet();
    }

    public int value() {
        return c.get();
    }

}
*** liveness (deadlock/starvation/livelock etc)

*** guarded blocks with wait and notify

USING:
Object.wait()
Object.notifyAll()



Threads often have to coordinate their actions. The most common coordination
idiom is the guarded block. Such a block begins by polling a condition that must
be true before the block can proceed. There are a number of steps to follow in
order to do this correctly.

Suppose, for example guardedJoy is a method that must not proceed until a shared
variable joy has been set by another thread. Such a method could, in theory,
simply loop until the condition is satisfied, but that loop is wasteful, since
it executes continuously while waiting.

public void guardedJoy() {
    // Simple loop guard. Wastes
    // processor time. Don't do this!
    while(!joy) {}
    System.out.println("Joy has been achieved!");
}

A more efficient guard invokes Object.wait to suspend the current thread. The
invocation of wait does not return until another thread has issued a
notification that some special event may have occurred — though not necessarily
the event this thread is waiting for:

public synchronized void guardedJoy() {
    // This guard only loops once for each special event, which may not
    // be the event we're waiting for.
    while(!joy) {
        try {
            wait();
        } catch (InterruptedException e) {}
    }
    System.out.println("Joy and efficiency have been achieved!");
}

Note: Always invoke wait inside a loop that tests for the condition being waited
for. Don't assume that the interrupt was for the particular condition you were
waiting for, or that the condition is still true.

Like many methods that suspend execution, wait can throw
InterruptedException. In this example, we can just ignore that exception — we
only care about the value of joy.

Why is this version of guardedJoy synchronized? Suppose d is the object we're
using to invoke wait. When a thread invokes d.wait, it must own the intrinsic
lock for d — otherwise an error is thrown. Invoking wait inside a synchronized
method is a simple way to acquire the intrinsic lock.

When wait is invoked, the thread releases the lock and suspends execution. At
some future time, another thread will acquire the same lock and invoke
Object.notifyAll, informing all threads waiting on that lock that something
important has happened:

public synchronized notifyJoy() {
    joy = true;
    notifyAll();
}

Some time after the second thread has released the lock, the first thread
reacquires the lock and resumes by returning from the invocation of wait.

NOTE: There is a second notification method, notify, which wakes up a single
thread. Because notify doesn't allow you to specify the thread that is woken up,
it is useful only in massively parallel applications — that is, programs with a
large number of threads, all doing similar chores. In such an application, you
don't care which thread gets woken up.

*** high level concurrency objects
**** Locks
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

use lock like this:
private final Lock lock = new ReentrantLock();
boolean isLocked = lock.tryLock(); // Acquires the lock only if it is free at the time of invocation
lock.unLock(); // Releases the lock
**** Executors
interface Executor
interface ExecutorService
interface ScheduledExecutorService

thread-pools

***** Fork/Join
The fork/join framework is an implementation of the ExecutorService interface
that helps you take advantage of multiple processors. It is designed for work
that can be broken into smaller pieces recursively. The goal is to use all the
available processing power to enhance the performance of your application.

As with any ExecutorService implementation, the fork/join framework distributes
tasks to worker threads in a thread pool. The fork/join framework is distinct
because it uses a work-stealing algorithm. Worker threads that run out of things
to do can steal tasks from other threads that are still busy.

The center of the fork/join framework is the ForkJoinPool class, an extension of
the AbstractExecutorService class. ForkJoinPool implements the core
work-stealing algorithm and can execute ForkJoinTask processes.  Basic Use

The first step for using the fork/join framework is to write code that performs
a segment of the work. Your code should look similar to the following
pseudocode:

if (my portion of the work is small enough)
  do the work directly
else
  split my work into two pieces
  invoke the two pieces and wait for the results

Wrap this code in a ForkJoinTask subclass, typically using one of its more
specialized types, either RecursiveTask (which can return a result) or
RecursiveAction.

After your ForkJoinTask subclass is ready, create the object that represents all
the work to be done and pass it to the invoke() method of a ForkJoinPool
instance.

**** Concurrent Collections
The java.util.concurrent package includes a number of additions to the Java Collections Framework. These are most easily categorized by the collection interfaces provided:

- BlockingQueue defines a first-in-first-out data structure that blocks or times out when you attempt to add to a full queue, or retrieve from an empty queue.
- ConcurrentMap is a subinterface of java.util.Map that defines useful atomic operations. These operations remove or replace a key-value pair only if the key is present, or add a key-value pair only if the key is absent. Making these operations atomic helps avoid synchronization. The standard general-purpose implementation of ConcurrentMap is ConcurrentHashMap, which is a concurrent analog of HashMap.
- ConcurrentNavigableMap is a subinterface of ConcurrentMap that supports approximate matches. The standard general-purpose implementation of ConcurrentNavigableMap is ConcurrentSkipListMap, which is a concurrent analog of TreeMap.

All of these collections help avoid Memory Consistency Errors by defining a happens-before relationship between an operation that adds an object to the collection with subsequent operations that access or remove that object.

* ================================ MISC ================================

// pause for 500 milliseconds
try {
    Thread.sleep(500);
} catch (InterruptedException e) {}



// SYSTEM PROPERTIES
// get user home dir
String home = System.getProperty("user.home");
// file separator
String home = System.getProperty("file.separator");



// ANSI TERMINAL CONTROL SEQUENCES
in java "\e" gets me an illegal control character exception...
... instead, use "\u001b"... unicode literal for ESC character

// EXAMPLES:
"\u001b[0G" --- goto beginning of line (Cursor Horizontal Absolute (column 0))
"\u001b[2K" --- Erase In Line (erase whole line)
"\u001b[0K" --- Erase In Line (erase from cursor to end of line)
"\u001b[1K" --- Erase In Line (erase from cursor to beginning of line)
* =============================== EMAIL ================================
** simple
import java.util.Properties;
import javax.mail.*;
import javax.mail.internet.*;

public void sendEmail() {
    String to = "benopod@hotmail.com";
    String from = "bstpg@bschambers.info";
    String host = "mail3.gridhost.co.uk"; //or IP address

    // Get the session object
    Properties props = System.getProperties();
    props.setProperty("mail.smtp.host", host);
    Session mailSession = Session.getDefaultInstance(properties);

    //compose the message
    try {
        Transport transport = mailSession.getTransport();
        MimeMessage message = new MimeMessage(mailSession);
        message.setFrom(new InternetAddress(from));
        message.addRecipient(Message.RecipientType.TO, new InternetAddress(to));
        message.setSubject("Test sending email with javax.mail");
        message.setText("message text");

        // Send message
        Transport.send(message);

    } catch (MessagingException e) {
        e.printStackTrace();
    }
}

** with authentication
import java.util.Properties;
import javax.mail.*;
import javax.mail.internet.*;
import javax.activation.*;

public void sendEmail() {
    String to = "benopod@hotmail.com";
    String from = "bstpg@bschambers.info";
    String host = "mail3.gridhost.co.uk"; //or IP address

    // Get the session object
    Properties props = new Properties();
    props.put("mail.transport.protocol", "smtp");
    props.put("mail.smtp.host", host);
    props.put("mail.smtp.auth", "true");
    Authenticator auth = new Authenticator() {
            @Override
            public PasswordAuthentication getPasswordAuthentication() {
                String username = "bstpg@bschambers.info";
                String password = "dangoLIOLO";
                return new PasswordAuthentication(username, password);
            }
        };
    Session mailSession = Session.getDefaultInstance(props, auth);
    // mailSession.setDebug(true); // uncomment for debugging info to stdout

    //compose the message
    try {
        Transport transport = mailSession.getTransport();
        MimeMessage message = new MimeMessage(mailSession);
        message.setFrom(new InternetAddress(from));
        message.addRecipient(Message.RecipientType.TO, new InternetAddress(to));
        message.setSubject("Test sending email with javax.mail");
        message.setText("message text");

        // Send message
        Transport.send(message);

    } catch (MessagingException e) {
        e.printStackTrace();
    }
}

** with attachment
// to add attachment, we need to use MimeMultipart

* REFLECTION
** GET INFORMATION ABOUT CLASS
import java.lang.reflect.Method;
import java.lang.reflect.Field;

for (Method m : String.class.getMethods())
    System.out.println(m);

for (Field f : String.class.getFields())
    System.out.println(f);
** INSTANTIATE CLASS FROM PATH AS STRING
// simple example for class with a no-args constructor
try {
  Class<BongoBongo> c = Class.forName("path.to.BongoBongo");
  BongoBongo bb = c.getDeclaredConstructor().newInstance();
} catch (ClassNotFoundException e) {}

** INSTANTIATE CLASS GETTING CONSTRUCTOR FROM EXISTING INSTANCE BY REFLECTION
try {
    // init new components object (should have a no-args contructor)
    Constructor<BuildComponents> noArgsConstructor =
        (Constructor<BuildComponents>) comp.getClass().getConstructor();
    comp = noArgsConstructor.newInstance();
} catch (NoSuchMethodException e) {
    e.printStackTrace();
} catch (InstantiationException e) {
    e.printStackTrace();
} catch (IllegalAccessException e) {
    e.printStackTrace();
} catch (InvocationTargetException e) {
    e.printStackTrace();
}
* SSL/CA-CERTIFICATES/KEYSTORE
CA (Certificate Authority) certificates are required for HTTP/SSL etc..
Java keeps CA certificates in a keystore...
** finding the keystore
Java should have a cacerts database...

$ locate cacerts

... if there are a lot of results you could narrow it down...

$ locate cacerts | grep java

... using java 11, so let's look at this one...

$ file /usr/lib/jvm/java-11-openjdk-amd64/lib/security/cacerts

... file says that it's a symbolic link...

$ ll /usr/lib/jvm/java-11-openjdk-amd64/lib/security/cacerts

... ls -l shows that the link points here - navigate to dir...

$ /etc/ssl/certs/java/cacerts
$ cd /etc/ssl/certs/java
$ file cacerts

... file says that this is a Java KeyStore


NOTE: There are a loto of other certificates on the system not stored in cacerts
format - just try $ locate ca-certificate

** inspecting the keystore
Use keytool to inspect the keystore...

$ cd /etc/ssl/certs/java
$ keytool -list -cacerts

... the default password is 'changeit'...
... you can put it on the command line if security is not high...

$ keytool -list -cacerts -storepass changeit

** adding certificates

haven't done this yet...
* RUN SHELL COMMAND
* =========================== PARSING XML ============================
** DOM or SAX
- DOM = Document Object Model
- SAX = Simple API for XML
** parsing XML tutorial/demo
https://www.tutorialspoint.com/java_xml/java_dom_parse_document.htm
