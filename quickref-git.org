==== GIT QUICKSTART GUIDE ============================================

* ==== BASIC USAGE (walkthrough) =====================================

GET MORE HELP:
    $ man gittutorial
    $ git help [COMMAND]



INSTALL:
    $ sudo apt-get install git



BASIC USAGE:
    $ git init                   # creates .git dir in current dir.
    $ git add [FILES...]         # add new files to be tracked.
    $ git status                 # to see what files I changed.
    $ git diff [FILE]            # to see exactly what I modified.
    $ git commit -a -m "message" # commit all modified files (but not new ones, unless you've added them)

    $ git log      # shows a log of all commits starting from HEAD back to the initial commit. (It can do more than that, of course.)
    $ git shortlog # concise version of log
    $ git status   # shows which files have changed between the current project state and HEAD. Files are put in one of three categories: new files that haven’t been added (with git add), modified files that haven’t been added, and files that have been added.
    $ git diff     # shows the diff between HEAD and the current project state. With the --cached option it compares added files against HEAD; otherwise it compares files not yet added (more precisely, git diff compares the staging area, that is, HEAD as modified by all added files, against the current state of all added files. Thus, if you add some but not all changed files and then run git diff, you will see only files that are changed but not added).
    $ git mv       # mark files to be moved (rename), much like git add.
    $ git rm       # mark files to be moved removed, much like git add.

    $ git ls-files # list files tracked in this repository

    $ git-push     # push local commits to a remote repository

    $ git-pull     # fetch from and integrate with another repository or a local branch

** basic usage walkthrough

Move into base directory of project (directory may or may not be empty).

    $ git init

Tell Git which files to include in the commit, with git add. If a file has not changed since the previous commit (the “parent” commit), Git will automatically include it in the commit you are about to perform. Thus, you only need to add files that you have added or modified. Note that it adds directories recursively, so git add . will add everything that has changed.

    $ git add

Call git commit to create the commit object. The new commit object will have the current HEAD as its parent (and then, after the commit is complete, HEAD will point to the new commit object).

    $ git commit

SHORTCUT:
    $ git commit -a # automatically add all modified files (but not new ones).

NOTE that if you modify a file but do not add it, then Git will include the previous version (before modifications) to the commit. The modified file will remain in place.

======================================================================

basic workflow might look like this:

Do some programming.
    $ git status                 # to see what files I changed
    $ git diff [file]            # to see exactly what I modified
    $ git commit -a -m "message" # to commit

** Referring to a Commit

Now that you’ve created commits, how do you refer to a specific commit? Git provides many ways to do so. Here are a few:

    By its SHA1 name, which you can get from git log.
    By the first few characters of its SHA1 name.
    By a head. For example, HEAD refers to the commit object referenced by HEAD. You can also use the name, such as master.
    Relative to a commit. Putting a caret (^) after a commit name retrieves the parent of that commit. For example, HEAD^ is the parent of the current head commit.

* ============== INFORMATION AND STATS ABOUT REPOSITORY ===============

List all source files...
$ git ls-files

Count number of source files...
$ git ls-files | wc -l

Count number of lines in all source files...
$ git ls-files | xargs wc -l

* ====================== VERIFYING YOUR COMMITS ======================

https://blog.nemit.fi/verify-your-github-commits-2fb42bff6048

* ==== CLONING A REPOSITORY ==========================================
** command line

 $ git clone https://github.com/bschambers/elisp-insanity-code

The format for github URL is https://github.com/YOUR-USERNAME/YOUR-REPOSITORY

** on github
1. Navigate to the main page of the repository
2. Click "Clone or download"
3. Either:
   1. Download the repository as a zip file
   2. Copy the URL provided and do 'git clone' in the terminal (as above)

* ==== BACKING UP A LOCAL REPOSITORY =================================

Backup repo into a single archive file so it can be emailed etc:
    $ git bundle create PATH/BACKUP_FILENAME --all

Unpacking archive file (NEW_DIR cannot already exist):
    $ git clone PATH/BACKUP_FILENAME PATH/NEW_DIR

* ==== BRANCHING =====================================================
** CREATING A NEW BRANCH

    git branch [new-head-name] [reference-to-(B)]

or, for example:

    git branch fix-headers HEAD^

This command will create a new head with the given name, and point that head at the requested commit object. If the commit object is left out, it will point to HEAD.

Now our commit tree looks like this:

    (A) -- (B) ------- (C)
            |           |
       fix-headers    master
                        |
                       HEAD

** SWITCHING BETWEEN BRANCHES

In order to start working on the headers, you need to set the fix-headers head
to be the current head. This is done with git checkout:

    git checkout [head-name]

This command does the following:

    Points HEAD to the commit object specified by [head-name]
    Rewrites all the files in the directory to match the files stored in the new HEAD commit.

Important note: if there are any uncommitted changes when you run git checkout,
Git will behave very strangely. The strangeness is predictable and sometimes
useful, but it is best to avoid it. All you need to do, of course, is commit all
the new changes before checking out the new head.

...

** Other useful commands at this point:

    $ git branch # with no arguments lists the existing heads, with a star next to the current head.
    $ git diff [head1]..[head2] # shows the diff between the commits referenced by head2 and head1.
    $ git diff [head1]...[head2] # (three dots) shows the diff between head2 and the common ancestor of head1 and head2. For example, diff master...fix-headers above would show the diff between (D) and (B).
    $ git log [head1]..[head2] # shows the change log between head2 and the common ancestor of head1 and head2. With three dots, it also shows the changes between head1 and the common ancestor; this is not so useful. (Switching head1 and head2, on the other hand, is very useful.)

** COMMON BRANCHING USE PATTERNS

A common way to use Git branching is to maintain one “main” or “trunk” branch
and create new branches to implement new features. Often the default Git branch,
master, is used as the main branch.

So, in the example above, it may have been better to leave master at (B), where
the paper was submitted to the reviewers. You could then start a new branch to
store changes regarding new data.

Ideally, in this pattern, the master branch is always in a releaseable
state. Other branches will contain half-finished work, new features, and so on.

This pattern is particularly important when there are multiple developers
working on a single project. If all developers are adding commits in sequence to
a single branch, then new features need to be added in a single commit, in order
not to cause the branch to become unusable. However, if each developer creates a
new branch to make a new feature, then commits can be made at any time, whether
or not they are unfinished.

This is what Git users mean when they say that COMMITS ARE CHEAP. If you are
working on your own branch, there is no reason you need to be particularly
careful about what you commit to the repository. It won’t affect anything else.

** MERGING

    $ git merge [head]
    $ git pull . [head]

They are identical in result. (Though the merge form seems simpler for now, the reason for the pull form will become apparent when discussing multiple developers.)

These commands perform the following operations. Let the current head be called current, and the head to be merged called merge.

    Identify the common ancestor of current and merge. Call it ancestor-commit.
    Deal with the easy cases. If the ancestor-commit equals merge, then do nothing. If ancestor-commit equals current, then do a fast forward merge.
    Otherwise, determine the changes between the ancestor-commit and merge.
    Attempt to merge those changes into the files in current.
    If there were no conflicts, create a new commit, with two parents, current and merge. Set current (and HEAD) to point to this new commit, and update the working files for the project accordingly.
    If there was a conflict, insert appropriate conflict markers and inform the user. No commit is created.

Important note: Git can get very confused if there are uncommitted changes in the files when you ask it to perform a merge. So make sure to commit whatever changes you have made so far before you merge.

** COMMON MERGE USE PATTERNS

There are two common reasons to merge two branches. The first, as explained above, is to draw the changes from a new feature branch into the main branch.

The second use pattern is to draw the main branch into a feature branch you are developing. This keeps the feature branch up to date with the latest bug fixes and new features added to the main branch. Doing this regularly reduces the risk of creating a conflict when you merge your feature into the main branch.

One disadvantage of doing the above is that your feature branch will end up with a lot of merge commits. An alternative that solves this problem is rebasing, although that comes with problems of its own.

** DELETING A BRANCH

After you have merged a development branch into the main branch, you probably don’t need the development branch anymore. Hence, you may want to delete it so it doesn’t clutter your git branch listing.

To delete a branch, use git branch -d [head]. This simply removes the specified head from the repository’s list of heads.

For example, in this repository from above:

             +---------- (D) ---------------+
            /             |                  \
    (A) -- (B) -- (C) -------------- (E) -- (F)
                          |                  |
                     fix-headers           master
                                             |
                                            HEAD

we probably don’t need the fix-headers head any more. So we can use:

    git branch -d fix-headers

and the resulting repository looks like:

             +---------- (D) ---------------+
            /                                \
    (A) -- (B) -- (C) -------------- (E) -- (F)
                                             |
                                           master
                                             |
                                            HEAD

Important note: git branch -d will cause an error if the branch to be deleted is not reachable from another head. Why? Consider the following repository:

             +----------- (E)
            /              |
    (A) -- (B) -- (C)      |
                   |       |
                 head1   head2

Say you delete head2. Now how can you use commit (E)? You can’t check it out, because it isn’t a head. And it doesn’t appear in any logs or anywhere else, because it isn’t an ancestor of head1. So commit (E) is practically useless. In Git terminology, it is a “dangling commit,” and its information is lost.

Git does allow you to use the -D option to force deletion of a branch that would create a dangling commit. However, it should be a rare situation that you want to do that. Think very carefully before using git branch -D.

* ============================= STASHING =============================

Often, when you’ve been working on part of your project, things are in a messy
state and you want to switch branches for a bit to work on something else. The
problem is, you don’t want to do a commit of half-done work just so you can get
back to this point later. The answer to this issue is the git stash command.

Stashing takes the dirty state of your working directory — that is, your
modified tracked files and staged changes — and saves it on a stack of
unfinished changes that you can reapply at any time.

$ git stash       # stashes all un-committed work and leaves the working directory clean

$ git stash list  # lists all stashes

$ git stash apply
$ git stash pop   # apply stash and then get rid of it

$ git stash drop  # get rid of a stash


CREATING A BRANCH FROM A STASH

$ git stash branch testchanges

... creates a new branch called testchanges, checks out the commit you were on
when you stashed your work, reapplies your work there, and then drops the stash
if it applies successfully

* ========================== CONFIGURATION ===========================
** THE BASICS
To list all settings that git can find:

 $ git config --list

To display an individual config setting:

 $ git config user.name

Use config command to change some settings:

 $ git config --global user.name "John Doe"
 $ git config --global user.email johndoe@example.com

These settings will apply globally --> omit '--global' and it will apply only to the local repo:

 $ git config user.name "John Doe"
 $ git config user.email johndoe@example.com

** ADVANCED CONFIGURATION

 Can manually create a config file:
 ~/.gitconfig

 ... but better way is to use GIT CONFIG command...
 ... you can use TAB completion and see all of the different options available...
 ... example (--global option is self explanatory):
 $ git config --global core.excludesfile ~/.gitignore

*** MY MINIMAL CONFIG:

 At present all I have done is to create a .gitignore file in my home dir and make .gitconfig simply to point git at .gitignore...

 [user]
	 name = BS Chambers
	 email = ben@bschambers.info
 [core]
         excludesfile = ~/.gitignore

*** .gitignore
 in .gitignore, put names of files you want git to ignore...
 ... at the moment, I just instruct it to ignore auto-save files:
 #+BEGIN_SRC
 *~
 #+END_SRC


 ... you can also put a local .gitignore file in your project directory...



 NOTES:
 ... directory paths are relative to the .gitignore file...
 ... if you want to specify a particular file, put preceeding slash to denote directory of .gitignore file
 ... put trailing slash to show that something is a directory

 build --> will match anthing with 'build' in the name
 /build --> match 'build' in same directory as .gitignore
 build/ --> match directory ending 'build'

 MORE COMPLEX EXAMPLE
 #+BEGIN_SRC
 # structure .gitignore as whitelist instead of blacklist

 # ignore everything in current dir
 /*

 # make a few exceptions
 !.gitignore
 !init.el
 !init-bsc/
 !init-bsc/*

 # ignore backup files in dir
 init-bsc/*~
 #+END_SRC

*** ADVANCED .gitconfig EXAMPLE (from pksunkara)

    :ADVANCED_GITCONFIG:
    [user]
    name = Pavan Kumar Sunkara
    email = pavan.sss1991@gmail.com
    [core]
    editor = vim
    whitespace = fix,-indent-with-non-tab,trailing-space,cr-at-eol
    excludesfile = ~/.gitignore
    [sendemail]
    smtpencryption = tls
    smtpserver = smtp.gmail.com
    smtpuser = pavan.sss1991@gmail.com
    smtppass = password
    smtpserverport = 587
    [web]
    browser = google-chrome
    [instaweb]
    httpd = apache2 -f
    [rerere]
    enabled = 1
    autoupdate = 1
    [push]
    default = matching
    [color]
    ui = auto
    [color "branch"]
    current = yellow bold
    local = green bold
    remote = cyan bold
    [color "diff"]
    meta = yellow bold
    frag = magenta bold
    old = red bold
    new = green bold
    whitespace = red reverse
    [color "status"]
    added = green bold
    changed = yellow bold
    untracked = red bold
    [diff]
    tool = vimdiff
    [difftool]
    prompt = false
    [github]
    user = pkumar
    token = token
    [gitflow "prefix"]
    feature = feature-
    release = release-
    hotfix = hotfix-
    support = support-
    versiontag = v
    [alias]
    a = add --all
    ai = add -i
    #############
    ap = apply
    as = apply --stat
    ac = apply --check
    #############
    ama = am --abort
    amr = am --resolved
    ams = am --skip
    #############
    b = branch
    ba = branch -a
    bd = branch -d
    br = branch -r
    #############
    c = commit
    ca = commit -a
    cm = commit -m
    cem = commit --allow-empty -m
    cam = commit -am
    cd = commit --amend
    cad = commit -a --amend
    ced = commit --allow-empty --amend
    #############
    d = diff
    dc = diff --cached
    dl = difftool
    dlc = difftool --cached
    dk = diff --check
    dp = diff --patience
    dck = diff --cached --check
    #############
    f = fetch
    fo = fetch origin
    fu = fetch upstream
    #############
    fp = format-patch
    #############
    fk = fsck
    #############
    g = grep -p
    #############
    l = log --oneline
    lg = log --oneline --graph --decorate
    #############
    ls = ls-files
    lsf = "!git ls-files | grep -i"
    #############
    m = merge
    ma = merge --abort
    mc = merge --continue
    ms = merge --skip
    #############
    o = checkout
    ob = checkout -b
    #############
    pr = prune -v
    #############
    ps = push
    psf = push -f
    psu = push -u
    pso = push origin
    psao = push --all origin
    psfo = push -f origin
    psuo = push -u origin
    psom = push origin master
    psfom = push -f origin master
    psuom = push -u origin master
    #############
    pl = pull
    plu = pull -u
    plo = pull origin
    plp = pull upstream
    plom = pull origin master
    plpm = pull upstream master
    #############
    pb = pull --rebase
    pbo = pull --rebase origin
    pbp = pull --rebase upstream
    pbom = pull --rebase origin master
    pbpm = pull --rebase upstream master
    #############
    rb = rebase
    rba = rebase --abort
    rbc = rebase --continue
    rbi = rebase --interactive
    rbs = rebase --skip
    #############
    re = reset
    rh = reset HEAD
    reh = reset --hard
    rem = reset --mixed
    res = reset --soft
    rehh = reset --hard HEAD
    remh = reset --mixed HEAD
    resh = reset --soft HEAD
    #############
    r = remote
    ra = remote add
    rr = remote rm
    rv = remote -v
    rm = remote rename
    rp = remote prune
    rs = remote show
    rao = remote add origin
    rau = remote add upstream
    rso = remote show origin
    rsu = remote show upstream
    rpo = remote prune origin
    rpu = remote prune upstream
    #############
    s = status
    sb = status -s -b
    #############
    sa = stash apply
    sc = stash clear
    sd = stash drop
    sl = stash list
    sp = stash pop
    ss = stash save
    sw = stash show
    #############
    w = show
    wp = show -p
    wr = show -p --no-color
    #############
    svnr = svn rebase
    svnd = svn dcommit
    svnl = svn log --oneline --show-commit
    #############
    assume = update-index --assume-unchanged
    unassume = update-index --no-assume-unchanged
    assumed = "!git ls-files -v | grep ^h | cut -c 3-"
    unassumeall = !git assumed | xargs git update-index --no-assume-unchanged
    assumeall = "!git st -s | awk {'print $2'} | xargs git assume"
    #############
    ours = "!f() { git checkout --ours $@ && git add $@; }; f"
    theirs = "!f() { git checkout --theirs $@ && git add $@; }; f"
    #############
    whois = "!sh -c 'git log -i -1 --pretty=\"format:%an <%ae>\n\" --author=\"$1\"' -"
    whatis = show -s --pretty='tformat:%h (%s, %ad)' --date=short
    #############
    barebranch = !sh -c 'git symbolic-ref HEAD refs/heads/$1 && git rm --cached -r . && git clean -xfd' -
    flat = clone --depth 1
    subpull = !git submodule foreach git pull --tags origin master
    subrepo = !sh -c 'filter-branch --prune-empty --subdirectory-filter $1 master' -
    human = name-rev --name-only --refs=refs/heads/*
    serve = !git daemon --reuseaddr --verbose  --base-path=. --export-all ./.git
    snapshot = !git stash save "snapshot: $(date)" && git stash apply "stash@{0}"
    :END:

* ====================== TAGS AND VERSION NUMBERS ======================

how to do version numbers...

list all tags...
$ git tag

list all tags matching pattern "v1.8*"
$ git tag -l "v1.8*"



lightweight and annotated tags...

... annotated tag is

** create annotated tag

$ git tag -a v1.8.5 -m "My new version 1.8.5"

-a --- create annotated tag
-m --- add message


can now reference this commit by the tag...
$ git show v1.8.5

** add tag retrospectively

include the beginning of the hash for the commit...
$ git tag -a v0.4.5 -m "Blah blah..." 0bc4dc5

* =========================== LISTING STUFF ============================

compact view of log history
$ git log --oneline

show all tracked files
$ git ls-files

* GIT-PUSH
** SETUP
*** username and email
Make sure that your Git username and email are configured. This is important,
since every Git commit will use this information to identify you as the author.

View the current global options to see whether your name and email are currently
configured correctly:

 $ git config --global --list

View individual config variables like this:

 $ git config --global user.name
 $ git config --global user.email

To set your name or email address, use the following commands:

 $ git config --global user.name "YOUR_USERNAME"
 $ git config --global user.email "your_email_address@example.com"

You’ll need to do this only once, since you are using the --global option. It
tells Git to always use this information for anything you do on that system. If
you want to override this with a different username or email address for
specific projects or repositories, you can run the command without the --global
option when you’re in that project, and that will default to --local. You can
read more on how Git manages configurations in the Git Config documentation.
Check your information

*** remote

To see a current list of remote repositories:

 $ git remove -v

To add a new remote repository:

 $ git remote add <source-name> <repository-path>

** USAGE

 $ git push <destination> <branch>

e.g.

 $ git push origin master

* GIT-PULL
* GITHUB SSH SETUP
** review your SSH keys on github
click on your profile picture to get up the menu

go to SSH and GPG keys

you will see a list of any SSH and GPG keys

you can delete them if you want

** check for existing SSH keys on computer

 $ ls -al ~/.ssh

Check the directory listing to see if you already have a public SSH key. By
default, the filenames of supported public keys for GitHub are one of the
following.

 id_rsa.pub
 id_ecdsa.pub
 id_ed25519.pub

** Either generate a new SSH key or upload an existing key.

If you don't have a supported public and private key pair, or don't wish to use
any that are available, generate a new SSH key.

If you see an existing public and private key pair listed (for example,
id_rsa.pub and id_rsa) that you would like to use to connect to GitHub, you can
add the key to the ssh-agent.

For more information about generation of a new SSH key or addition of an
existing key to the ssh-agent, see "Generating a new SSH key and adding it to
the ssh-agent."

** Generating a new SSH key

 $ ssh-keygen -t ed25519 -C "your_email@example.com"

This creates a new SSH key, using the provided email as a label.

When you're prompted to "Enter a file in which to save the key," press
Enter. This accepts the default file location.

At the prompt, type a secure passphrase.

** Adding your SSH key to the ssh-agent

(Before adding a new SSH key to the ssh-agent to manage your keys, you should have checked for existing SSH keys and generated a new SSH key)

Start the ssh-agent in the background.

 $ eval "$(ssh-agent -s)"

Depending on your environment, you may need to use a different command. For
example, you may need to use root access by running sudo -s -H before starting
the ssh-agent, or you may need to use exec ssh-agent bash or exec ssh-agent zsh
to run the ssh-agent.

Add your SSH private key to the ssh-agent. If you created your key with a
different name, or if you are adding an existing key that has a different name,
replace id_ed25519 in the command with the name of your private key file.

 $ ssh-add ~/.ssh/id_ed25519

** Adding a new SSH key to your GitHub account

Copy the SSH public key to your clipboard

 $ cat ~/.ssh/id_ed25519.pub
 # Then select and copy the contents of the id_ed25519.pub file
 # displayed in the terminal to your clipboard

If your SSH public key file has a different name than the example code, modify the filename to match your current setup. When copying your key, don't add any newlines or whitespace.

Login to Github

Click your profile picture to open the menu:
- click Settings
- click SSH and GPG keys
- click New SSH key or Add SSH key

In the "Title" field, add a descriptive label for the new key. For example, if you're using a personal Mac, you might call this key "Personal MacBook Air".

Paste your key into the "Key" field.

Click Add SSH key.

If prompted, confirm your GitHub password.

** Switching remote URLs from HTTPS to SSH

Change the current working directory to your local project.

List your existing remotes in order to get the name of the remote you want to change.

 $ git remote -v
 > origin  https://github.com/USERNAME/REPOSITORY.git (fetch)
 > origin  https://github.com/USERNAME/REPOSITORY.git (push)

Change your remote's URL from HTTPS to SSH with the git remote set-url command.

 $ git remote set-url origin git@github.com:USERNAME/REPOSITORY.git

Verify that the remote URL has changed.

 $ git remote -v
 # Verify new remote URL
 > origin  git@github.com:USERNAME/REPOSITORY.git (fetch)
 > origin  git@github.com:USERNAME/REPOSITORY.git (push)

* PERSONAL ACCESS TOKEN (PAT)

GENERAL NOTES
- delete PATs as soon as they are not needed
- set short expiry dates

GENERATE A NEW PAT:
- Settings-->Developer Settings-->Personal Access Tokens
- create a new token
- choose settings for new PAT:
  - NOTE: some identifying info
  - EXPIRY:
  - SCOPE: usually just choose "repo"
- copy the generated token and STORE IT SOMEWHERE SAFE!
